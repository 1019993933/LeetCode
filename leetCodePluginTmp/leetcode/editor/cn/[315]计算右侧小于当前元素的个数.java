// ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼ŒæŒ‰è¦æ±‚è¿”å›ä¸€ä¸ªæ–°æ•°ç»„ countsã€‚æ•°ç»„ counts æœ‰è¯¥æ€§è´¨ï¼š counts[i] çš„å€¼æ˜¯ nums[i] å³ä¾§å°äº num
// s[i] çš„å…ƒç´ çš„æ•°é‡ã€‚
//
//
//
// ç¤ºä¾‹ï¼š
//
// è¾“å…¥ï¼šnums = [5,2,6,1]
// è¾“å‡ºï¼š[2,1,1,0]
// è§£é‡Šï¼š
// 5 çš„å³ä¾§æœ‰ 2 ä¸ªæ›´å°çš„å…ƒç´  (2 å’Œ 1)
// 2 çš„å³ä¾§ä»…æœ‰ 1 ä¸ªæ›´å°çš„å…ƒç´  (1)
// 6 çš„å³ä¾§æœ‰ 1 ä¸ªæ›´å°çš„å…ƒç´  (1)
// 1 çš„å³ä¾§æœ‰ 0 ä¸ªæ›´å°çš„å…ƒç´ 
//
//
//
//
// æç¤ºï¼š
//
//
// 0 <= nums.length <= 10^5
// -10^4 <= nums[i] <= 10^4
//
// Related Topics æ’åº æ ‘çŠ¶æ•°ç»„ çº¿æ®µæ ‘ äºŒåˆ†æŸ¥æ‰¾ åˆ†æ²»ç®—æ³•
// ğŸ‘ 499 ğŸ‘ 0

import java.util.*;

// leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        if (nums==null || nums.length==0) {
            return new ArrayList<>();
        }
        if (nums.length==1)
        {
            ArrayList<Integer> lst = new ArrayList<>();
            lst.add(0);
            return lst;
        }

        // é‡‡ç”¨å¿«æ’ï¼Œå¯¹æ¯ä¸€ä¸ªæ•°ï¼Œåœ¨å…¶å³ä¾§æ•°ç»„ä¸­æ‰¾åˆ°å…¶å¿«æ’çš„ä½ç½®ï¼Œæœ‰äº†è¯¥ä½ç½®å³å¯è®¡ç®—å‡ºå·¦ä¾§ä¸å³ä¾§çš„å€¼
        // è¿™ä¸ªæƒ³æ³•æ˜¯é”™è¯¯çš„ï¼Œé¦–å…ˆå¿«æ’è¿‡ç¨‹ä¸­æ”¹å˜äº†åŸæ•°ç»„çš„å‰åå…³ç³»ï¼Œåé¢è®¡ç®—çš„éƒ½ä¸æ˜¯å‡†ç¡®å€¼
        // å…¶å®ï¼Œé‡‡ç”¨å¿«æ’çš„æ€æƒ³æ—¶é—´å¤æ‚ä¸ºO(n^2),åŒç­‰äºæš´åŠ›è§£æ³•


        //å½’å¹¶æ’åºæ— æ³•è§£å†³æ­¤é—®é¢˜ï¼Œå½’å¹¶æ’åºå¯ä»¥ç»Ÿè®¡æ‰€æœ‰çš„é€†åºå¯¹æ•°é‡ï¼Œä½†æ˜¯ç”±äºæ’åºç»“æœç§»åŠ¨äº†å…ƒç´ ä½ç½®ï¼Œæ— æ³•æ¯ä¸ªä½ç½®å¯¹åº”çš„é€†åºæ•°é‡
        //===============

        //æ ‘çŠ¶æ•°ç»„çš„é€šç”¨å…¬å…±ä¸º  a*f(j)+b < f(i) < c*f(j)+d, ç”±äºåœ¨å¾ªç¯è¿‡ç¨‹å¯¹æ¯ä¸€ä¸ªj,ç»Ÿè®¡çš„æ˜¯jä¹‹å‰çš„æ»¡è¶³å…³ç³»çš„içš„æ•°é‡ï¼Œ
        // å³æ»¡è¶³å…³ç³»çš„å·¦è¾¹çš„æ•°é‡ï¼ŒæŒ‰æ­¤é¢˜æ„åªéœ€è¦å°†åŸæ•°ç»„å…ˆé€†åºå³å¯
        // æˆ–è€…ä»åå¾€å‰éå†

        // è§£æ³•ä¸€ï¼šåŸå§‹æš´åŠ›è§£æ³•
//        return solution1(nums);

        // è§£æº‰äºŒï¼šæ ‘çŠ¶æ•°ç»„
        return  solutionWithFenwickTree(nums);
    }

    //==============è§£æ³•ä¸€ï¼Œä½œä¸ºè§£é¢˜æ€è·¯
    // å…ˆå¤åˆ¶ä¸€ä»½æ•°ç»„ï¼ŒåŸå¤åˆ¶åçš„æ•°ç»„æ’åºï¼Œç„¶åå»é‡ï¼Œå†å¯¹å»é‡åçš„æ•°ç»„ï¼Œå®šä¹‰ä¸€ä¸ªç›¸åº”é•¿åº¦çš„æ•°ç»„ï¼ˆæ¡¶ï¼‰ç”¨æ¥å­˜å‚¨å¯¹åº”å…ƒç´ çš„ä¸ªæ•°
    // æ¡¶çš„æ•°ç»„ä¸‹æ ‡å¯¹åº”ç€åŸæ¥å…ƒç´ çš„å€¼ï¼Œè¿™æ ·æ¡¶çš„é¡ºåºå…³ç³»å³ååº”äº†åŸæ•°ç»„çš„æ’åºå…³ç³»
    // æ¡¶çš„å€¼åˆå§‹åŒ–ä¸º0
    // ç„¶åå†å¯¹åŸæ•°ç»„ä»åå¾€å‰è¿›è¡Œéå†ï¼Œ æ­¤éå†é¡ºåºå…³ç³»å³ä¿è¯äº†åªæœ‰åœ¨è¯¥å…ƒç´ åé¢çš„æ•°å€¼æ‰ä¼šå‡ºç°åœ¨æ¡¶æ•°ç»„ä¸­ï¼Œæ‰€ä»¥å¯¹æ¡¶å½“å‰æ•°ç»„çš„å…ƒç´ ç»Ÿè®¡å³ååº”äº†å¦‚ä¸‹å…³ç³»
    // è®¾å½“å‰æŸ¥è¯¢çš„åŸæ•°ç»„ä¸‹æ ‡i, å¯¹k=nums[i]çš„æ¡¶ä¸‹æ ‡,æ¡¶æ•°ç»„kä¹‹å‰çš„æ‰€æœ‰å…ƒç´ å€¼æ±‚å’Œï¼Œå…¶å¯¹åº”çš„å®é™…æ„ä¹‰ä¸º åœ¨åŸæ•°ç»„iä¹‹åçš„å…ƒç´ ä¸­å°äºkçš„å…ƒç´ ä¸ªæ•°ï¼Œæ¡¶æ•°ç»„kä¹‹åçš„å€¼æ±‚å’Œï¼Œè¡¨ç¤ºåŸæ•°ç»„iä¹‹åå…ƒç´ å¤§äºkçš„å…ƒç´ ä¸ªç´ ï¼ˆä»…åœ¨å½“ä¸‹æœ‰æ•ˆï¼Œä¸‹æ¬¡æ›´æ–°åå³ä¸¢å¤±äº†è¿™ä¸ªä¿¡æ¯ï¼‰
    // å½“å¤„ç†å®Œå½“å‰çš„kä¹‹åï¼Œå°†kå¯¹åº”çš„æ¡¶å…ƒç´ å€¼ +1ï¼Œ å³è¡¨ç¤ºè¿™ä¸ªå…ƒç´ æ”¾ä¸‹æ¡¶ä¸­ï¼Œä»¥ä¾¿ä¸‹ä¸€ä¸ªå…ƒç´ çš„ç»Ÿè®¡å¯ä»¥ä½¿ç”¨
    private List<Integer> solution1(int[] nums) {
        //1ï¼š åŸæ•°ç»„ä¸­çš„å€¼å¯¹åº”æ¡¶çš„ä¸‹æ ‡ï¼ˆå‡è®¾åŸæ•°ç»„ä¸­æ²¡æœ‰è´Ÿæ•°ï¼‰ï¼Œæ±‚åŸæ•°ç»„ä¸­æœ€å¤§å€¼ï¼Œè¿™ä¸ªå°±å¯ä»¥çŸ¥é“éœ€è¦ç”¨å¤šå°‘ä¸ªæ¡¶
        int maxValue = Arrays.stream(nums).max().getAsInt();
        int [] bucket = new int[maxValue+1]; //æ¡¶åˆå§‹åŒ–å®Œæˆåï¼Œå¯¹åŸæ•°ç»„ä»»ä¸€å…ƒç´ nums[i], bucket[nums[i]]å³è¡¨ç¤ºè¯¥å…ƒç´ çš„ä¸ªæ•°ï¼Œæ­¤å¤„çš„æ€æƒ³å¯ä»¥å‚è€ƒè®¡æ•°æ’åº

        // å­˜æ”¾ç»“æœçš„æ•°ç»„
        Integer[] count = new Integer[nums.length];
        for (int i = nums.length-1; i >= 0; i--) {
            int curCount = 0;

            //å¯¹æ¡¶è¯¥ä¸‹æ ‡å‰é¢çš„å…ƒç´ æ±‚å’Œï¼Œå³ä¸ºå°äºiä½ç½®çš„å…ƒç´ æ•°é‡ï¼ˆè¿™äº›å…ƒç´ éƒ½æ˜¯åœ¨iä¹‹åçš„ï¼Œç¬¬ä¸€é‡å¾ªç¯ä¿è¯äº†è¿™ä¸€ç‚¹ï¼‰
            for (int j = 0; j < nums[i]; j++) {
                curCount += bucket[j];
            }
            count[i] = curCount;

            //å°†å½“å‰çš„å€¼åŠ åˆ°æ¡¶ä¸­
            bucket[nums[i]] += 1;
        }

        return Arrays.asList(count);
    }

    //---------------æ–¹æ³•ä¸€çš„æ¼”è¿›
    private List<Integer> solution2(int[] nums) {
        //å®é™…ä¸Šï¼Œæˆ‘ä»¬ä¸åŒéœ€è¦0åˆ°maxValueçš„ç©ºé—´åšæ¡¶ï¼Œå› ä¸ºå…¶ä¸­å¯èƒ½æœ‰å¤§é‡çš„æ— æ•ˆæ¡¶ï¼ŒåŒæ—¶å¦‚æœæœ‰è´Ÿæ•°çš„æƒ…å†µï¼Œæ­¤å¤„ä¹Ÿä¸èƒ½ç›´æ¥å¯¹åº”ä¸‹æ ‡
        //ä¼˜åŒ–çš„æ–¹æ³•å³ä¸ºå¯¹åŸæ•°ç»„çš„å…ƒç´ è¿›è¡Œç¦»æ•£åŒ–ï¼Œç¦»æ•£åŒ–çš„æ„æ€å°±æ˜¯å°†åŸæ•°å€¼çš„å€¼ç©ºé—´æ˜ å°„åˆ°ä¸€ä¸ªæ²¡æœ‰é‡å¤çš„[0~n]çš„è¿ç»­ç©ºé—´
        //ä¸€ç§å¤„ç†æ–¹æ³•ä¸ºé€šè¿‡TreeSetè¿›è¡Œå»é‡æ’åº
        int maxValue = Arrays.stream(nums).max().getAsInt();
        int [] bucket = new int[maxValue+1];

        //å†åˆ©ç”¨Hashmapå­˜å‚¨TreeSetä¸­çš„å…ƒç´ ä¸å…¶ä¸‹æ ‡çš„å¯¹åº”å…³ç³»


        Integer[] count = new Integer[nums.length];

        //åœ¨è®¡ç®—æŸä¸ªæ¡¶çš„å‰é¢çš„å…ƒç´ æ•°é‡æ—¶ï¼Œä¸€ç§åº”å¯¹å¤§é‡æ•°æ®çš„æ›´åŠ æœ‰æ•ˆçš„æ•°æ®ç»“æœå°±æ˜¯ æ ‘çŠ¶æ•°ç»„
        //åœ¨æ ‘çŠ¶æ ‘ç»„ä¸­æ¯ä¸€ä¸ªå¤§äº0çš„å…ƒç´ å€¼ï¼Œå…¶å«ä¹‰ä¸ºå…¶å‰é¢çš„æ‰€æœ‰å…ƒç´ çš„å’Œï¼Œè¿™æ ·å°±å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„get(nums[i])æ¥ä»£æ›¿ä¸‹é¢çš„å¾ªç¯

        //ä¸‹é¢è¿™ä¸ªå¾ªç¯ï¼Œå…¶æœ€ç»ˆçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ï¼Œå…¶å®é™…ä¸Šå°±æ˜¯å¯¹æ¯ä¸€ä¸ªä¸‹æ ‡kï¼Œæ±‚kä¹‹å‰çš„æ‰€æœ‰å…ƒç´ çš„å’Œï¼Œè§£å†³æ­¤é—®é¢˜çš„ä¸€ä¸ªæœ‰æ•ˆçš„æ•°æ®ç»“æ„å³ä¸ºæ ‘çŠ¶æ•°ç»„
        //å¯¹åº”æ ‘çŠ¶æ•°ç»„çš„æŸ¥è¯¢æ“ä½œä¸æ›´æ–°æ“ä½œï¼Œæ—¶é—´å¤æ‚åº¦å‡ä¸ºO(logN),æœ€ç»ˆå¤æ‚åº¦ä¸ºO(NlogN)
        for (int i = nums.length-1; i >= 0; i--) {
            int curCount = 0;

            for (int j = 0; j < nums[i]; j++) {
                curCount += bucket[j];
            }
            count[i] = curCount;

            //æ›´æ–°æ“ä½œï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„çš„updateæ–¹æ³•æ¥æ›´æ–°ï¼Œ
            bucket[nums[i]] += 1;
        }

        return Arrays.asList(count);
    }

    //===============æ–¹æ³•äºŒï¼Œåˆ©ç”¨æ ‘çŠ¶æ•°ç»„
    private List<Integer> solutionWithFenwickTree(int[] nums) {
        Set<Integer> set = new TreeSet<>();
        for (int i = 0; i < nums.length; i++) {
            set.add(nums[i]);
        }

        HashMap<Integer, Integer> values = new HashMap<>();
        int idx = 0;
        for(int x: set){
            values.put(x, idx++);
        }

        BitTree tree = new BitTree(values.size()+1);
        List<Integer> lst = new ArrayList<>();

        Integer[] count = new Integer[nums.length];

        int left = 0;
        for (int i = nums.length-1; i >= 0; i--) {
            // åŸå§‹åºå·ä¸æ ‘çŠ¶æ•°ç»„åºå·å­˜åœ¨å·®1çš„å…³ç³»ï¼Œå³åŸå§‹åºå·0å¯¹åº”æ ‘çŠ¶æ•°ç»„åºå·1
            // å¯¹æ ‘çŠ¶æ•°ç»„åºå·1å–å€¼ï¼Œå…¶å«ä¹‰ä¸ºæ ‘æ•°ç»„ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ æ¡¶åºå·0ï¼‰çš„å‰ç¼€å’Œå³ä¸ºtree[1]={tree[0]+...+tree[1-1]} = tree[0] = 0(ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å…ƒç´ ï¼Œå…¶å‰é¢çš„å’Œè‡ªç„¶ä¸º0)
            // æ ‘çŠ¶æ•°ç»„åºå·ä¸º nums.lengthï¼Œå¯¹åº”æ¡¶æ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ nums.length-1çš„å‰ç¼€å’Œ
            idx = values.get(nums[i]);
            int treeIdx =  idx+1;
            count[i] = tree.query(treeIdx);
            tree.update(treeIdx+1, 1);
        }

        return Arrays.asList(count);
    }

    public class BitTree{
        private int[] tree;
        private int n;

        public BitTree(int n){
            this.n = n+1;
            this.tree = new int[this.n];
        }

        public void update(int i, int val){
            while(i<n){
                tree[i] += val;
                i += lowbit(i);
            }
        }

        public int query(int i){
            int ans = 0;
            while(i>0){
                ans += tree[i];
                i -= lowbit(i);
            }

            return ans;
        }

        private int lowbit(int x){
            return (x & (-x));
        }
    }


}
// leetcode submit region end(Prohibit modification and deletion)
